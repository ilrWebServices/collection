<?php

// $Id$

/**
 * @file
 * Allows administrators to define content types as 'collections', which group nodes together.
 *
 * Provides a block to show which collections a node is part of, when viewing
 * the node, and allows for custom rendering of nodes in that block.
 *
 * Relies on CCK nodereference module to do the actual referencing.
 */

/**
 * $node->build_mode is set to this when building collection for block
 * display. Makes it easy for node.tpl.php (or its overrides) to change the
 * appearance of collections in blocks. Also allows CCK to make the display of
 * fields configurable.
 */
define('NODE_BUILD_COLLECTION', 100);
/**
 * $node->build_mode is set to this for nodes listed, allowing for
 * customisation through CCKs interface and custom node.tpl.php handling.
 */
define('NODE_BUILD_COLLECTION_LIST', 101);

/**
 * Implementation of hook_menu().
 */
function collection_menu() {
  $items['admin/content/node-type/%/collection_update'] = array(
    'title' => 'Update collection',
    'access arguments' => array('administer content types'),
    'page callback' => 'collection_update_type',
    'page arguments' => array(3),
    'access arguments' => array('administer content types'),
    'type' => MENU_CALLBACK,
  );
  return $items;
}

/**
 * Implementation of hook_nodeapi().
 * Used for maintaining backrefs, and setting $node->collection.
 */
function collection_nodeapi(&$node, $op, $teaser = FALSE, $page = FALSE) {
  switch ($op) {
    case 'load':
      // Set $node->collections for all nodes that's part of a collection.
      if ($collections = collection_nodes($node)) {
        return array(
          'collections' => $collections,
        );
      }
      break;
    case 'save':
    case 'insert':
    case 'update':
      // Update backrefs when collections are saved.
      if (collection_field_name($node->type)) {
        collection_update_backrefs($node);
      }
      break;
    case 'delete':
      // Delete backrefs when features are deleted.
      if (collection_field_name($node->type)) {
        collection_delete_backrefs($node);
      }
      break;
  }
}

/**
 * Implementation of hook_form_alter().
 */
function collection_form_node_type_form_alter(&$form, &$form_state) {
  $type = $form['old_type']['#value'];

  $fields = array(NULL => t('Not a collection'));
  $content_type = content_types($type);
  if ($content_type['fields']) {
    foreach ($content_type['fields'] as $name => $field) {
      if ($field['type'] == 'nodereference') {
        $fields[$field['field_name']] = t($field['widget']['label']);
      }
    }
  }
  
  $form['collection'] = array(
    '#type' => 'fieldset',
    '#title' => t('Collection settings'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
  );

  $form['collection']['collection_field_name'] = array(
    '#type' => 'select',
    '#title' => t('Node reference field'),
    '#options' => $fields,
    '#default_value' => variable_get('collection_field_name_'. $type, NULL),
    '#description' => t('The node reference field on the collection type that lists nodes that is part of this collection.'),
  );

  $form['collection']['rescan'] = array(
    '#type' => 'item',
    '#value' => l(t('Update back references'), 'admin/content/node-type/' . $type . '/collection_update',
                  array('query' => drupal_get_destination())
    ),
    '#description' => t('You need to update the back references if you change the field used, or if the back references gets out of sync for another reason.'),
  );
}

/**
 * Implementation of hook_block().
 */
function collection_block($op, $delta = 0, $edit = array()) {
  switch ($op) {
    case 'list':
      return array(
        0 => array(
          'info' => t('Collection listing'),
          'cache' => BLOCK_CACHE_PER_PAGE,
        ),
        1 => array(
          'info' => t('In same collection(s)'),
          'cache' => BLOCK_CACHE_PER_PAGE,                    
        ),
      );
      break;
    case 'view':
      switch ($delta) {
        case 0:
          // Show a listing of the nodes in the same collection, when viewing
          // a node in a collection.
          if ($node = collection_in_collection()) {
            foreach ($node->collections as $collection_node) {
              // $node->collection_hidden allows modules to suppress the display of some collection nodes.
              if (!isset($node->collection_hidden) or !$node->collection_hidden) {
                $collection_node->build_mode = NODE_BUILD_COLLECTION;
                $content .= node_view($collection_node);
              }
            }
            return array(
              'subject' => t('Collection listing'),
              'content' => $content,
            );           
          }
          break;
        case 1:
          // Show a listing of the nodes in the same collection, when viewing
          // a node in a collection.
          if ($node = collection_in_collection()) {
            foreach ($node->collections as $collection) {
              $nodes = array();
              foreach ($collection->{collection_field_name($collection->type)} as $delta => $cnode) {
                if ($cnode = node_load($cnode['nid'])) {
                  $cnode->build_mode = NODE_BUILD_COLLECTION_LIST;
                  $nodes[] = node_view($cnode, TRUE);
                }
              }
              $content .= theme('collection_node_list', $nodes, $collection, $node);
            }
            return array(
              'subject' => t('In same collection(s)'),
              'content' => $content,
            );           
          }
          break;
      }

      break;
  }
}

/**
 * Implementation of hook_theme().
 */
function collection_theme() {
  return array(
    'collection_node_list' => array(
      'arguments' => array('nodes' => array(), 'collection' => NULL, 'node' => NULL),
    ),
  );
}

/**
 * Implementation of hook_content_build_modes().
 */
function collection_content_build_modes() {
 return array(
   'collection' => array(
     'title' => t('Collection'),
     'build modes' => array(
       NODE_BUILD_COLLECTION => array(
         'title' => t('Collections block'),
         'views style' => FALSE,
       ),
       NODE_BUILD_COLLECTION_LIST => array(
         'title' => t('Collection article listing block'),
         'views style' => FALSE,
       ),
     ),
   ),
 );
}

// --- Theming functions ---

/**
 * Theme the listing of related nodes in the "In same collection(s)" block.
 */
function theme_collection_node_list($nodes, $collection, $node) {
  return join('', $nodes);
}


// --- Misc. functions ---

/**
 * Helper function to figure out if we're looking at a node that's part of a
 * collection. 
 */
function collection_in_collection() {
  if ($node = menu_get_object() and $node->collections) {
    return $node;
  }
  return NULL;
}


/**
 * Returns the node reference field for the collection type.
 */
function collection_field_name($type) {
  return variable_get('collection_field_name_' . $type, NULL);
  
}

/**
 * Get the collection nodes for a given node.
 */
function collection_nodes($node) {
  $nodes = array();
  // Ordering by nid is not the most optimal, but we need a stable
  // default. Modules can implement hook_collection_alter to rearrange afterwards.
  $result = db_query('SELECT collection_nid FROM {collection_backref} WHERE nid = %d ORDER BY collection_nid', $node->nid);
  while ($row = db_fetch_object($result)) {
    // Filter out any missing nodes (they could be deleted).
    if ($n = node_load($row->collection_nid)) {
      $n->collection_weight = 0;
      $nodes[] = $n;
    }
  }
  // Allow modules to alter the collection.
  drupal_alter('collection', $nodes, $node);
  usort($nodes, '_collection_sort');
  return $nodes;
}

/**
 * Helper for uasort to sort collections by weight.
 */
function _collection_sort($a, $b) {
  if ($a->collection_weight == $b->collection_weight) {
    if ($a->title == $b->title) {
      return 0;
    }
    return ($a->title < $b->title) ? -1 : 1;
  }
  return ($a->collection_weight < $b->collection_weight) ? -1 : 1;  
}

/**
 * Menu callback. Starts a batch operation.
 */
function collection_update_type($type) {
  $batch = array(
    'title' => t('Updating collection back references'),
    'operations' => array(
      array('_collection_batch', array($type)),
    ),
    'finished' => '_collection_batch_finished',
  );
  batch_set($batch);
  // batch_process('admin/content/node-type/' . $type);
  batch_process('admin/content/node-type/' . $type);
}

/**
 * Batch function, processes 10 collection nodes.
 */
function _collection_batch($type, &$context) {
  if (empty($context['sandbox'])) {
    $context['sandbox']['progress'] = 0;
    $context['sandbox']['current_node'] = 0;
    $context['sandbox']['max'] = db_result(db_query("SELECT COUNT(DISTINCT nid) FROM {node} WHERE type = '%s'", $type));
  }
  
  $limit = 10;
  $result = db_query_range("SELECT nid FROM {node} WHERE nid > %d AND type = '%s' ORDER BY nid ASC", $context['sandbox']['current_node'], $type, 0, $limit);
  while ($row = db_fetch_array($result)) {
    $node = node_load($row['nid'], NULL, TRUE);
    $context['results'][] = $node->nid .' : '. $node->title;
    $context['sandbox']['progress']++;
    $context['sandbox']['current_node'] = $node->nid;
    $context['message'] = $node->title;
    collection_update_backrefs($node);
  }
  if ($context['sandbox']['progress'] != $context['sandbox']['max']) {
    $context['finished'] = $context['sandbox']['progress'] / $context['sandbox']['max'];
  }
}

/**
 * Batch finished function, notifies user of result.
 */
function _collection_batch_finished($success, $results, $operations) {
  if ($success) {
    $message = format_plural(count($results), 'One collection processed.', '@count collections processed.');
  }
  else {
    $message = t('Finished with an error.');
  }
  drupal_set_message($message);
}


/**
 * Update backrefs to collections.
 *
 * Maintains a list of node to collection back references, in order not to
 * kill the DB when we need to find the collection for a node.
 */
function collection_update_backrefs($node) {
  collection_delete_backrefs($node);
  if ($field_name = collection_field_name($node->type) and $node->{$field_name}) {
    foreach ($node->{$field_name} as $collection_nodes) {
      if ($collection_nodes['nid']) {
        db_query('INSERT INTO {collection_backref} (nid, collection_nid) VALUES (%d, %d)',
                 $collection_nodes['nid'], $node->nid);
      }
    }
  }
}

/**
 * Delete backrefs to a feature.
 * Used when feature nodes are deleted.
 */
function collection_delete_backrefs($node) {
  db_query('DELETE FROM {collection_backref} WHERE collection_nid = %d', $node->nid);
}
